using UnityEngine;
using System.Collections.Generic;
using Utils;

namespace Map
{ 
    /// <summary>
    /// Class responsible for managing the map. From its creation with the altitude map generating by MapGenerator
    ///  to providing map's related methods used by other clases.
    /// <seealso cref="MapGenerator"/>
    /// </summary>
    public class MapManager : GenericManager<MapManager>
    {

        #region Private variables

        private Tuple<int, BlockType>[][] _mapShape;
        private MapTile[][] _realMap;
        private Dictionary<BlockType, GameObject> _mapBlocks;
        private TerrainTheme terrainTheme;
        private const float VERTICAL_DIST = 0.82f;

        #endregion

        #region Serialize fields

        [SerializeField]private GameObject[] stoneBlocks;
        [SerializeField]private GameObject[] grassBlocks;
        [SerializeField]private GameObject waterBlock;
        [SerializeField]private GameObject mapFolder;

        [SerializeField]private int mapRows = 4;
        [SerializeField]private int mapCols = 10;

        #endregion

        #region Properties

        public int MapCols
        {
            get { return mapCols; }
        }

        public int MapRows
        {
            get { return mapRows; }
        }

        #endregion

        #region Event functions

        /// <summary>
        /// Called just before the first frame, it will creates the whole map. Each TerrainTheme corresponds to 
        /// a visually different type of block (grass, stone or mix between them) and it will be used to add 
        /// randomness to the map generation.
        /// </summary>
        void Start()
        {
            //Dictionary that links each block type to a certain block Sprite storage in stoneBlocks or grassBlocks.
            _mapBlocks = new Dictionary<BlockType, GameObject>(4);

            int rand = Random.Range(0, 2);

            //The theme is chosen randomly
            terrainTheme = (TerrainTheme)rand;
            if (terrainTheme == TerrainTheme.BlockGrass)
            {
                for (int i = 0; i < grassBlocks.Length; ++i)
                    _mapBlocks.Add((BlockType)i, grassBlocks[i]);
            }
            else if (terrainTheme == TerrainTheme.BlockStone)
            {
                for (int i = 0; i < stoneBlocks.Length; ++i)
                    _mapBlocks.Add((BlockType)i, stoneBlocks[i]);
            }
            else
            {
                for (int i = 0; i < stoneBlocks.Length; ++i)
                    _mapBlocks.Add((BlockType)i, Random.Range(0, 10) % 2 == 0 ? stoneBlocks[i] : grassBlocks[i]);
            }

            _mapShape = MapGenerator.GenerateMap(mapRows, mapCols);
            _realMap = new MapTile[mapRows][];


            Vector3 spriteSize = stoneBlocks[0].GetComponent<SpriteRenderer>().sprite.bounds.size;
            float posX = transform.position.x - (int)(mapCols / 2) * spriteSize.x + spriteSize.x / 2;
            float posY = transform.position.y + (int)(mapRows / 2) * VERTICAL_DIST;
            Vector3 tilePosition;

            //The map is generated by instantiating the corresponding blocks
            for (int i = 0; i < mapRows; ++i)
            {
                _realMap[i] = new MapTile[mapCols];
                for (int j = 0; j < mapCols; ++j)
                {
                    tilePosition = new Vector3(posX + spriteSize.x * j, posY - VERTICAL_DIST * i, 20 - i * 2);
                    _realMap[i][j] = new MapTile(tilePosition, new Vector2(i, j), _mapShape[i][j], _mapBlocks, mapFolder, waterBlock, _mapShape);
                }
            }

        }

        #endregion

        #region Public methods


        /// <summary>
        /// Returns a random position in the map's given row (before the first element or after the last element), adding a
        /// little offset. It is used by SpawnManager as spawn position of entities.
        /// </summary>
        /// <param name="row">Row position of the map</param>
        /// <returns>Random world position in the row given after adding an offset.</returns>
        public Vector3 GetRandomSpawnPosition(int row)
        {

            int rand = Random.Range(0, 10);
            Vector3 position;
            if (rand % 2 == 0)
            {
                position = GetTopTilePosition(row, 0);
                position.x -= 1.0f;
            }
            else
            {
                position = GetTopTilePosition(row, mapCols - 1);
                position.x += 1.0f;
            }
            position.y += 0.05f;
            float minZ = 20;
            for(int i = 0; i < mapCols; ++i)
            {
                Vector3 topTilePos = GetTopTilePosition(row, i);
                if (topTilePos.z < minZ)
                    minZ = topTilePos.z;                    
            }
            position.z = minZ;
            return position;
        }

        #endregion

        #region Private methods

        /// <summary>
        /// Returns the world position of the top block in the tile indicated by "row" and "col"
        /// </summary>
        /// <param name="row">Row position of the tile.</param>
        /// <param name="col">Column position of the tile.</param>
        /// <returns>World position of the tile's top block.</returns>
        private Vector3 GetTopTilePosition(int row, int col)
        {
            return _realMap[row][col].TopBlockPosition;
        }
        #endregion

    }
}